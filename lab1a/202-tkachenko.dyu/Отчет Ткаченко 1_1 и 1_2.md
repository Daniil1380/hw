# Протокол TCP

Сначала опишем наш протокол:

```
0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Version    |    Protocol   |     Total Length of Data      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Flags |reserve|                   Data checksum               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| new version reserved file size|	        file size	        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                           file                                |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                                                               |
|                                                               |
|                     Data in json format                       |
|                                                               |
|                                                               |
|                                                               |
|                                                               |
|                                                               |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

```

Протокол состоит из трех частей: Header - содержит 12 байт (версия протокола, название протокола, длина сообщения, флаги, зарезервированные слова, чем-сумма данных, размер файла), далее идет сам файл, переданный побайтово (если 4-й флаг равен 0, то поле файла пустое, далее идут данные переданные побайтово в json-формате). 

Посмотрим теперь на работу нашего протокола и этапы:



```
 Server                                                          Client
	|	    Header(first flag)+TimeZone+Header(second flag)+Name	|
	|	<+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|	1
	|																|
	|		Header + Hello message to all hosts						|	
	|+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+>   |	2
	|																|
	|					Header + may be file + message				|	
	|	<+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|	3
	|																|
	|		Header + may be file + message to all hosts				|
	|+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+>   |	4
	|																|	
	|							Header+bye							|
	|	<+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|	5
	|																|
	|		Header + bye message for all hosts						|
	|+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+>   |	6
    

```

Что касаемо неблокирующих сокетов: был полностью создан неблокирующий сервер и на половину (как дополнительное усложнение) неблокирующий клиент. Клиент не парсит пришедшие сообщения (по скольку его выполнение не было обязательным в принципе), однако в остальном работает полностью верно. Основной целью было заставить работать блокирующий и неблокирующий сервера с обоими видами клиентов. То есть теперь можно выбрать любую конфигурацию из:

##### Bserv+NBclient, NBserv+Bclient, NBserv+NBclient, Bserv+Bclient

Проверим работу неблокирующих сокетов, возьмем такую конфигурацию: NBServ+NBclient+Bclient и передадим файл с неблокирующего на блокирующий клиент.

Файл:

> ```
> На Пьера опять нашла та тоска, которой он так боялся. Он три дня после произнесения своей речи в ложе лежал дома на диване, никого не принимая и никуда не выезжая.
> В это время он получил письмо от жены, которая умоляла его о свидании, писала о своей грусти по нем и о желании посвятить ему всю свою жизнь.
> В конце письма она извещала его, что на днях приедет в Петербург из-за границы.
> Вслед за письмом в уединение Пьера ворвался один из менее других уважаемых им братьев-масонов и, наведя разговор на супружеские отношения Пьера, в виде братского совета, высказал ему мысль о том, что строгость его к жене несправедлива и что Пьер отступает от первых правил масона, не прощая кающуюся.
> В это же время теща его, жена князя Василья, присылала за ним, умоляя его хоть на несколько минут посетить ее для переговоров о весьма важном деле. Пьер видел, что был заговор против него, что его хотели соединить с женою, и это было даже не неприятно ему в том состоянии, в котором он находился. Ему было все равно: Пьер ничего в жизни не считал делом большой важности, и под влиянием тоски, которая теперь овладела им, он не дорожил ни своею свободою, ни своим упорством в наказании жены.
> «Никто не прав, никто не виноват, стало быть, и она не виновата», — думал он. — Ежели Пьер не изъявил тотчас же согласия на соединение с женою, то только потому, что в состоянии тоски, в котором он находился, он не был в силах ничего предпринять. Ежели бы жена приехала к нему, он бы теперь не прогнал ее. Разве не все равно было в сравнении с тем, что занимало Пьера, жить или не жить с женою?
> Не отвечая ничего ни жене, ни теще, Пьер раз поздним вечером собрался в дорогу и уехал в Москву, чтобы повидаться с Иосифом Алексеевичем. Вот что писал Пьер в дневнике своем.
> «Москва, 17-го ноября.
> Сейчас только приехал от благодетеля и спешу записать все, что я испытал при этом. Иосиф Алексеевич живет бедно и страдает третий год мучительною болезнью пузыря. Никто никогда не слыхал от него стона или слова ропота. С утра и до поздней ночи, за исключением часов, когда он кушает самую простую пищу, он работает над наукой. Он принял меня милостиво и посадил подле себя на кровати, на которой он лежал; я сделал ему знак рыцарей Востока и Иерусалима, он ответил мне тем же и с кроткой улыбкой спросил меня о том, что я узнал и приобрел в прусских и шотландских ложах. Я рассказал ему все, как умел, передал те основания, которые я предлагал в нашей Петербургской ложе, и сообщил о дурном приеме, сделанном мне, и о разрыве, происшедшем между мною и братьями. Иосиф Алексеевич, изрядно помолчав и подумав, на все это изложил мне свой взгляд, который мгновенно осветил мне все прошедшее и весь будущий путь, предлежащий мне. Он удивил меня, спросив о том, помню ли я, в чем состоит троякая цель ордена: 1) в хранении и познании таинства; 2) в очищении и исправлении себя для восприятия оного и 3) в исправлении рода человеческого чрез стремление к таковому очищению. Какая есть главнейшая и первая цель из этих трех? Конечно, собственное исправление и очищение. Только к этой цели мы можем всегда стремиться независимо от всех обстоятельств. Но вместе с тем эта-то цель и требует от нас наиболее трудов, и потому, заблуждаясь гордостью, мы, упуская эту цель, беремся либо за таинство, которое недостойны воспринять по нечистоте своей, либо беремся за исправление рода человеческого, когда сами из себя являем пример мерзости и разврата. Иллюминатство не есть чистое учение именно потому, что оно увлеклось общественной деятельностью и преисполнено гордости. На этом основании Иосиф Алексеевич осудил мою речь и всю мою деятельность. Я согласился с ним в глубине души своей. По случаю разговора нашего о моих семейных делах он сказал мне: „Главная обязанность истинного масона, как я сказал вам, состоит в совершенствовании самого себя. Но часто мы думаем, что, удалив от себя все трудности нашей жизни, мы скорее достигнем этой цели; напротив, государь мой, сказал он мне, только в среде светских волнений можем мы достигнуть трех главных целей: 1) самопознания, ибо человек может познавать себя только через сравнение, 2) совершенствования, только борьбой достигается оно, и 3) достигнуть главной добродетели — любви к смерти. Только превратности жизни могут показать нам тщету ее и могут содействовать нашей врожденной любви к смерти, или возрождению к новой жизни“. Слова эти тем более замечательны, что Иосиф Алексеевич, несмотря на свои тяжкие физические страдания, никогда не тяготится жизнию, а любит смерть, к которой он, несмотря на всю чистоту и высоту своего внутреннего человека, не чувствует себя еще достаточно готовым. Потом благодетель объяснил мне вполне значение великого квадрата мироздания и указал на то, что тройственное и седьмое число суть основание всего. Он советовал мне не отстраняться от общения с петербургскими братьями и, занимая в ложе только должности 2-го градуса, стараться, отвлекая братьев от увлечений гордости, обращать их на истинный путь самопознания и совершенствования. Кроме того, для себя лично советовал мне первее всего следить за самим собою, и с этою целью дал мне тетрадь, ту самую, в которой я пищу и буду вписывать впредь все свои поступки».
> «Петербург, 23-го ноября.
> Я опять живу с женою. Теща моя в слезах приехала ко мне и сказала, что Элен здесь и что она умоляет меня выслушать ее, что она невинна, что она несчастна моим оставлением и многое другое. Я знал, что ежели я только допущу себя увидать ее, то не в силах буду более отказать ей в ее желании. В сомнении своем я не знал, к чьей помощи и совету прибегнуть. Ежели бы благодетель был здесь, он бы сказал мне. Я удалился к себе, перечел письма Иосифа Алексеевича, вспомнил свои беседы с ним и из всего вывел то, что я не должен отказывать просящему и должен подать руку помощи всякому, тем более человеку, столь связанному со мною, и должен нести крест свой. Но ежели я для добродетели простил ее, то пускай и будет мое соединение с нею иметь одну духовную цель. Так я решил и так написал Иосифу Алексеевичу. Я сказал жене, что прошу ее забыть все старое, прошу простить мне то, в чем я мог быть виноват перед нею, а что мне прощать ей нечего. Мне радостно было сказать ей это. Пусть она не знает, как тяжело мне было вновь увидать ее. Устроился в большом доме в верхних покоях и испытываю счастливое чувство обновления».
> Основные отличия Java IO и Java NIO
> Программирование *
> Java *
> Из песочницы
> Когда я начал изучать стандартный ввод/вывод в Java, то первое время был немного шокирован обилием интерфейсов и классов пакета java.io.*, дополненных еще и целым перечнем специфических исключений.
> 
> Потратив изрядное количество часов на изучение и реализацию кучи разнообразных туториалов из Интернета, начал чувствовать себя уверенно и вздохнул с облегчением. Но в один прекрасный момент понял, что для меня все только начинается, так как существует еще и пакет java.nio.*, известный ещё под названием Java NIO или Java New IO. Вначале казалось, что это тоже самое, ну типа вид сбоку. Однако, как оказалось, есть существенные отличия, как в принципе работы, так и в решаемых с их помощью задачах.
> 
> Разобраться во всем этом мне здорово помогла статья Джакоба Дженкова (Jakob Jenkov) – “Java NIO vs. IO”. Ниже она приводиться в адаптированном виде.
> 
> Поспешу заметить, что статья не является руководством по использованию Java IO и Java NIO. Её цель – дать людям, начинающим изучать Java, возможность понять концептуальные отличия между двумя указанными инструментами организации ввода/вывода.
> 
> Основные отличия между Java IO и Java NIO
> 
> IO NIO
> Потокоориентированный  Буфер-ориентированный
> Блокирующий (синхронный) ввод/вывод    Неблокирующий (асинхронный) ввод/вывод
> Селекторы
> 
> Потокоориентированный и буфер-ориентированный ввод/вывод
> 
> Основное отличие между двумя подходами к организации ввода/вывода в том, что Java IO является потокоориентированным, а Java NIO – буфер-ориентированным. Разберем подробней.
> 
> Потокоориентированный ввод/вывод подразумевает чтение/запись из потока/в поток одного или нескольких байт в единицу времени поочередно. Данная информация нигде не кэшируются. Таким образом, невозможно произвольно двигаться по потоку данных вперед или назад. Если вы хотите произвести подобные манипуляции, вам придется сначала кэшировать данные в буфере.
> 
> Потокоориентированный ввод:
> 
> 
> 
> Потокоориентированный вывод:
> 
> 
> 
> Подход, на котором основан Java NIO немного отличается. Данные считываются в буфер для последующей обработки. Вы можете двигаться по буферу вперед и назад. Это дает немного больше гибкости при обработке данных. В то же время, вам необходимо проверять содержит ли буфер необходимый для корректной обработки объем данных. Также необходимо следить, чтобы при чтении данных в буфер вы не уничтожили ещё не обработанные данные, находящиеся в буфере.
> 
> Блокирующий и неблокирующий ввод/вывод
> 
> Потоки ввода/вывода (streams) в Java IO являются блокирующими. Это значит, что когда в потоке выполнения (tread) вызывается read() или write() метод любого класса из пакета java.io.*, происходит блокировка до тех пор, пока данные не будут считаны или записаны. Поток выполнения в данный момент не может делать ничего другого.
> 
> Неблокирующий режим Java NIO позволяет запрашивать считанные данные из канала (channel) и получать только то, что доступно на данный момент, или вообще ничего, если доступных данных пока нет. Вместо того, чтобы оставаться заблокированным пока данные не станут доступными для считывания, поток выполнения может заняться чем-то другим.
> 
> Каналы (channels)
> 
> 
> 
> 
> Тоже самое справедливо и для неблокирующего вывода. Поток выполнения может запросить запись в канал некоторых данных, но не дожидаться при этом пока они не будут полностью записаны.
> 
> Таким образом неблокирующий режим Java NIO позволяет использовать один поток выполнения для решения нескольких задач вместо пустого прожигания времени на ожидание в заблокированном состояний. Наиболее частой практикой является использование сэкономленного времени работы потока выполнения на обслуживание операций ввода/вывода в другом или других каналах.
> 
> Селекторы
> 
> Селекторы в Java NIO позволяют одному потоку выполнения мониторить несколько каналов ввода. Вы можете зарегистрировать несколько каналов с селектором, а потом использовать один поток выполнения для обслуживания каналов, имеющих доступные для обработки данные, или для выбора каналов, готовых для записи.
> 
> Чтобы лучше понять концепцию и выгоду от применения селекторов, давайте абстрагируемся от программирования и представим себе железнодорожный вокзал. Вариант без селектора: есть три железнодорожных пути (каналы), на каждый из них в любой момент времени может прибыть поезд (данные из буфера), на каждом пути постоянно ожидает сотрудник вокзала (поток выполнения), задача которого – обслуживание прибывшего поезда. В результате трое сотрудников постоянно находятся на вокзале даже если там вообще нет поездов. Вариант с селектором: ситуация та же, но для каждой платформы есть индикатор, сигнализирующий сотруднику вокзала (поток выполнения) о прибытии поезда. Таким образом на вокзале достаточно присутствия одного сотрудника.
> 
> Влияние Java NIO и Java IO на дизайн приложения
> 
> Выбор между Java NIO и Java IO может на следующие аспекты дизайна вашего приложения:
> 1. API обращений к классам ввода/вывода;
> 2. Обработка данных;
> 3. Количество потоков выполнения, использованных для обработки данных.
> 
> API обращений к классам ввода/вывода
> 
> Естественно, использование Java NIO серьезно отличается от использования Java IO. Так как, вместо чтения данных байт за байтом с использованием, например InputStream, данные для начала должны быть считаны в буфер и браться для обработки уже оттуда.
> 
> Обработка данных
> 
> Обработка данных при использовании Java NIO тоже отличается.
> Как уже упоминалось, при использовании Java IO вы читаете данные байт за байтом с InputStream или Reader. Представьте, что вы проводите считывание строк текстовой информации:
> 
> Name: Anna
> Age: 25
> Email: anna@mailserver.com
> Phone: 1234567890
> 
> Этот поток строк текста может обрабатываться следующим образом:
> 
> InputStream input = ... ;
> BufferedReader reader = new BufferedReader(new InputStreamReader(input));
> String nameLine   = reader.readLine();
> String ageLine    = reader.readLine();
> String emailLine  = reader.readLine();
> String phoneLine  = reader.readLine();
> 
> Обратите внимание, как состояние процесса обработки зависит от того, насколько далеко продвинулось выполнение программы. Когда первый метод readLine() возвращает результат выполнения, вы уверенны – целая строка текста была считана. Метод является блокирующим и действие блокировки продолжается до тех пор, пока вся строка не будет считана. Вы также четко понимаете, что данная строка содержит имя. Подобно этому, когда метод вызывается во второй раз, вы знаете, что в результате получите возраст.
> 
> Как вы видите, прогресс в выполнении программы достигается только тогда, когда доступны новые данные для чтения, и для каждого шага вы знаете что это за данные. Когда поток выполнения достигает прогресса в считывании определенной части данных, поток ввода (в большинстве случаев) уже не двигает данные назад. Данный принцип хорошо демонстрирует следующая схема:
> 
> 
> 
> Имплементация с использованием Java IO будет выглядеть несколько иначе:
> 
> ByteBuffer buffer = ByteBuffer.allocate(48);
> int bytesRead = inChannel.read(buffer);
> 
> Обратите внимание на вторую строчку кода, в которой происходит считывание байтов из канала в ByteBuffer. Когда возвращается результат выполнения данного метода, вы не можете быть уверенны, что все необходимые вам данные находятся внутри буфера. Все, что вам известно, так это то, что буфер содержит некоторые байты. Это немного усложняет процесс обработки.
> 
> Представьте, что после первого вызова метода read(buffer), в буфер было считано только половину строки. Например, “Name: An”. Сможете ли вы обработать такие данные? Наверное, что нет. Вам придется ждать пока, по крайней мере, одна полная строка текста не будет считана в буфер.
> 
> Так как же вам узнать, достаточно ли данных для корректной обработки содержит буфер? А никак. Единственный вариант узнать, это посмотреть на данные, содержащиеся внутри буфера. В результате вам придется по нескольку раз проверять данные в буфере, пока они не станут доступными для корректной обработки. Это неэффективно и может негативно сказаться на дизайне программы. Например:
> 
> ByteBuffer buffer = ByteBuffer.allocate(48);
>    int bytesRead = inChannel.read(buffer);
>       while(! bufferFull(bytesRead) ) {
>           bytesRead = inChannel.read(buffer);
>       }
> 
> 
> Метод bufferFull() должен следить за тем, сколько данных считано в буфер и возвращать true или false, в зависимости от того, заполнен буфер или нет. Другими словами, если буфер готов к обработке, то он считается заполненным.
> 
> Также метод bufferFull() должен оставлять буфер в неизмененном состоянии, поскольку в противном случае следующая порция считанных данных может быть записана в неправильное место.
> 
> Если буфер заполнен, данные из него могут быть обработаны. Если он не заполнен вы все же будете иметь возможность обработать уже имеющиеся в нем данные, если это имеет смысл в вашем конкретном случае. В большинстве случаев – это бессмысленно.
> 
> Следующая схема демонстрирует процесс определения готовности данных в буфере для корректной обработки:
> 
> 
> 
> Итоги
> 
> Java NIO позволяет управлять несколькими каналами (сетевыми соединениями или файлами) используя минимальное число потоков выполнения. Однако ценой такого подхода является более сложный, чем при использовании блокирующих потоков, парсинг данных.
> 
> Если вам необходимо управлять тысячами открытых соединений одновременно, причем каждое из них передает лишь незначительный объем данных, выбор Java NIO для вашего приложения может дать преимущество. Дизайн такого типа схематически изображен на следующем рисунке:
> 
> 
> 
> Если вы имеете меньшее количество соединений, по которым передаются большие объемы данных, то лучшим выбором станет классический дизайн системы ввода/вывода:
> 
> 
> 
> Важно понимать, что Java NIO отнюдь не является заменой Java IO. Его стоит рассматривать как усовершенствование – инструмент, позволяющий значительно расширить возможности по организации ввода/вывода. Грамотное использование мощи обоих подходов позволит вам строить хорошие высокопроизводительные системы.
> 
> Стоит заметить, что с выходом версии Java 1.7 появился еще и Java NIO.2, но присущие ему новшества касаются, в первую очередь, работы с файловым вводом/выводом, поэтому выходят за рамки этой статьи.
> 
> PS: также в данном посте использованы материалы очень достойной статьи Nino Guarnacci – «Java.nio vs Java.io»
> Теги: java niojava io
> Хабы: ПрограммированиеJava
> +21
> 
> 441
> 17
> +17
> 
> Редакторский дайджест
> Присылаем лучшие статьи раз в месяц
> 
> Электропочта
> 
> 12
> Карма
> 0
> Рейтинг
> Aleksandr Vengrovskyi @alexVengrovsk
> Пользователь
> 
> Комментарии 17
> 
> 
> pyatigil
> 04.09.2014 в 12:09
> Глаз режет расшифровка nio как new io. С чего бы это, если nio означает non-blocking io?
> +5
> 
> 
> Crazybot
> 04.09.2014 в 14:31
> Я сморозил
> 0
> 
> 
> kozhevnikovv
> 04.09.2014 в 20:31
> Я думаю ноги растут из википедии.
> 0
> 
> 
> QtRoS
> 04.09.2014 в 20:33
> Вот это поворот, всю жизнь думал, что это new io (и мысленно ругал, ибо что потом будет, newest io и тд?)
> +4
> 
> pyatigil
> 05.09.2014 в 15:50
> потом, как теперь известно, стало NIO2: jcp.org/en/jsr/detail?id=203
> +1
> 
> 
> drJonnie
> 04.09.2014 в 21:07
> Нет, в джаве это именно расшифровыется как new io. Вот полное название JSR 51: New I/O APIs for the JavaTM Platform. В седьмой добавили NIO.2 JSR 203: More New I/O APIs for the JavaTM Platform («NIO.2»)
> +16
> 
> pyatigil
> 04.09.2014 в 23:31
> Спасибо, не знал!
> 0
> 
> alexVengrovsk
> 05.09.2014 в 08:30
> Спасибо за комментарий. Старое доброе правило работает: «Если сомневаешься, то смотри стандартную документацию»
> 0
> 
> 
> fshp
> 05.09.2014 в 12:57
> nbio тогда назывался бы.
> 0
> 
> Avers
> 08.09.2014 в 16:33
> Версию new IO предлагает также Греберт Шилдт (Java Полное руководство, у меня 8е идание стр. 641)
> +1
> 
> 
> in3gant
> 04.09.2014 в 13:54
> Java IO было с первых версий, Java NIO появилось только с 1.4, отсюда можно вывести, что Новая
> -1
> 
> Cupper
> 05.09.2014 в 01:29
> ByteBuffer buffer = ByteBuffer.allocate(48);
> int bytesRead = inChannel.read(buffer);
> while(! bufferFull(bytesRead) ) {
> bytesRead = inChannel.read(buffer);
> }
> 
> 
> are you kidding me? Never use this approach, it's way to nowhere. You need to better learn what selector is and how to use non-blocking operations.
> +2
> 
> alexVengrovsk
> 05.09.2014 в 08:27
> You are right! But in this article this source code is not a tutorial of using Selector, it is an example of wrong desigh approach. That is why before this code I wrote: «Это неэффективно и может негативно сказаться на дизайне программы. Например:». The translation of this phrase is — «It isn't effective and can have a negative impact on app design. For example:»
> 0
> 
> Cupper
> 05.09.2014 в 10:13
> Oh, I've missed it :) But I still think it's not good way to present non-bloking part of library. It's better to say that we could do something in blocking mode but in some cases it's bad solutions and at this time we can use non-bloking IO and bla bla bla.
> I'm writing on english just because I don't have rus keyboard at work and I still can read russian :)
> 0
> 
> 
> eyeless_watcher
> 05.09.2014 в 10:44
> translit.net/
> +6
> 
> Slider_X
> 06.09.2014 в 00:12
> www.google.com/search?q=обучение%20слепой%20печати
> +2
> 
> 
> R_Voland
> 08.04.2020 в 15:05
> Вот интересно что будет если прибудут сразу три поезда? Куда кинется сотрудник вокзала?
> В целом же — в каждом из вариантов свои проблемы. IO тратит больше ресурсов на сетевую подсистему и меньше на обработку данных, NIO — наоборот.
> 0
> Только полноправные пользователи могут оставлять комментарии. Войдите, пожалуйста.
> Реклама
> ПОХОЖИЕ ПУБЛИКАЦИИ
> 9 марта 2020 в 13:47
> Вопросы к собеседованию Java-backend, Java core (60 вопросов)
> +15
> 134K
> 
> 552
> 76
> +76
> 15 февраля 2014 в 13:40
> Вопросы и задания для русскоязычной книги Thinking in Java (Философия Java) Брюса Эккеля
> +17
> 173K
> 
> 389
> 21
> +21
> 27 октября 2013 в 23:14
> g
> g
> g
> g
> g
> g
> На Пьера опять нашла та тоска, которой он так боялся. Он три дня после произнесения своей речи в ложе лежал дома на диване, никого не принимая и никуда не выезжая.
> В это время он получил письмо от жены, которая умоляла его о свидании, писала о своей грусти по нем и о желании посвятить ему всю свою жизнь.
> В конце письма она извещала его, что на днях приедет в Петербург из-за границы.
> Вслед за письмом в уединение Пьера ворвался один из менее других уважаемых им братьев-масонов и, наведя разговор на супружеские отношения Пьера, в виде братского совета, высказал ему мысль о том, что строгость его к жене несправедлива и что Пьер отступает от первых правил масона, не прощая кающуюся.
> В это же время теща его, жена князя Василья, присылала за ним, умоляя его хоть на несколько минут посетить ее для переговоров о весьма важном деле. Пьер видел, что был заговор против него, что его хотели соединить с женою, и это было даже не неприятно ему в том состоянии, в котором он находился. Ему было все равно: Пьер ничего в жизни не считал делом большой важности, и под влиянием тоски, которая теперь овладела им, он не дорожил ни своею свободою, ни своим упорством в наказании жены.
> «Никто не прав, никто не виноват, стало быть, и она не виновата», — думал он. — Ежели Пьер не изъявил тотчас же согласия на соединение с женою, то только потому, что в состоянии тоски, в котором он находился, он не был в силах ничего предпринять. Ежели бы жена приехала к нему, он бы теперь не прогнал ее. Разве не все равно было в сравнении с тем, что занимало Пьера, жить или не жить с женою?
> Не отвечая ничего ни жене, ни теще, Пьер раз поздним вечером собрался в дорогу и уехал в Москву, чтобы повидаться с Иосифом Алексеевичем. Вот что писал Пьер в дневнике своем.
> «Москва, 17-го ноября.
> Сейчас только приехал от благодетеля и спешу записать все, что я испытал при этом. Иосиф Алексеевич живет бедно и страдает третий год мучительною болезнью пузыря. Никто никогда не слыхал от него стона или слова ропота. С утра и до поздней ночи, за исключением часов, когда он кушает самую простую пищу, он работает над наукой. Он принял меня милостиво и посадил подле себя на кровати, на которой он лежал; я сделал ему знак рыцарей Востока и Иерусалима, он ответил мне тем же и с кроткой улыбкой спросил меня о том, что я узнал и приобрел в прусских и шотландских ложах. Я рассказал ему все, как умел, передал те основания, которые я предлагал в нашей Петербургской ложе, и сообщил о дурном приеме, сделанном мне, и о разрыве, происшедшем между мною и братьями. Иосиф Алексеевич, изрядно помолчав и подумав, на все это изложил мне свой взгляд, который мгновенно осветил мне все прошедшее и весь будущий путь, предлежащий мне. Он удивил меня, спросив о том, помню ли я, в чем состоит троякая цель ордена: 1) в хранении и познании таинства; 2) в очищении и исправлении себя для восприятия оного и 3) в исправлении рода человеческого чрез стремление к таковому очищению. Какая есть главнейшая и первая цель из этих трех? Конечно, собственное исправление и очищение. Только к этой цели мы можем всегда стремиться независимо от всех обстоятельств. Но вместе с тем эта-то цель и требует от нас наиболее трудов, и потому, заблуждаясь гордостью, мы, упуская эту цель, беремся либо за таинство, которое недостойны воспринять по нечистоте своей, либо беремся за исправление рода человеческого, когда сами из себя являем пример мерзости и разврата. Иллюминатство не есть чистое учение именно потому, что оно увлеклось общественной деятельностью и преисполнено гордости. На этом основании Иосиф Алексеевич осудил мою речь и всю мою деятельность. Я согласился с ним в глубине души своей. По случаю разговора нашего о моих семейных делах он сказал мне: „Главная обязанность истинного масона, как я сказал вам, состоит в совершенствовании самого себя. Но часто мы думаем, что, удалив от себя все трудности нашей жизни, мы скорее достигнем этой цели; напротив, государь мой, сказал он мне, только в среде светских волнений можем мы достигнуть трех главных целей: 1) самопознания, ибо человек может познавать себя только через сравнение, 2) совершенствования, только борьбой достигается оно, и 3) достигнуть главной добродетели — любви к смерти. Только превратности жизни могут показать нам тщету ее и могут содействовать нашей врожденной любви к смерти, или возрождению к новой жизни“. Слова эти тем более замечательны, что Иосиф Алексеевич, несмотря на свои тяжкие физические страдания, никогда не тяготится жизнию, а любит смерть, к которой он, несмотря на всю чистоту и высоту своего внутреннего человека, не чувствует себя еще достаточно готовым. Потом благодетель объяснил мне вполне значение великого квадрата мироздания и указал на то, что тройственное и седьмое число суть основание всего. Он советовал мне не отстраняться от общения с петербургскими братьями и, занимая в ложе только должности 2-го градуса, стараться, отвлекая братьев от увлечений гордости, обращать их на истинный путь самопознания и совершенствования. Кроме того, для себя лично советовал мне первее всего следить за самим собою, и с этою целью дал мне тетрадь, ту самую, в которой я пищу и буду вписывать впредь все свои поступки».
> «Петербург, 23-го ноября.
> Я опять живу с женою. Теща моя в слезах приехала ко мне и сказала, что Элен здесь и что она умоляет меня выслушать ее, что она невинна, что она несчастна моим оставлением и многое другое. Я знал, что ежели я только допущу себя увидать ее, то не в силах буду более отказать ей в ее желании. В сомнении своем я не знал, к чьей помощи и совету прибегнуть. Ежели бы благодетель был здесь, он бы сказал мне. Я удалился к себе, перечел письма Иосифа Алексеевича, вспомнил свои беседы с ним и из всего вывел то, что я не должен отказывать просящему и должен подать руку помощи всякому, тем более человеку, столь связанному со мною, и должен нести крест свой. Но ежели я для добродетели простил ее, то пускай и будет мое соединение с нею иметь одну духовную цель. Так я решил и так написал Иосифу Алексеевичу. Я сказал жене, что прошу ее забыть все старое, прошу простить мне то, в чем я мог быть виноват перед нею, а что мне прощать ей нечего. Мне радостно было сказать ей это. Пусть она не знает, как тяжело мне было вновь увидать ее. Устроился в большом доме в верхних покоях и испытываю счастливое чувство обновления».
> Основные отличия Java IO и Java NIO
> Программирование *
> Java *
> Из песочницы
> Когда я начал изучать стандартный ввод/вывод в Java, то первое время был немного шокирован обилием интерфейсов и классов пакета java.io.*, дополненных еще и целым перечнем специфических исключений.
> 
> Потратив изрядное количество часов на изучение и реализацию кучи разнообразных туториалов из Интернета, начал чувствовать себя уверенно и вздохнул с облегчением. Но в один прекрасный момент понял, что для меня все только начинается, так как существует еще и пакет java.nio.*, известный ещё под названием Java NIO или Java New IO. Вначале казалось, что это тоже самое, ну типа вид сбоку. Однако, как оказалось, есть существенные отличия, как в принципе работы, так и в решаемых с их помощью задачах.
> 
> Разобраться во всем этом мне здорово помогла статья Джакоба Дженкова (Jakob Jenkov) – “Java NIO vs. IO”. Ниже она приводиться в адаптированном виде.
> 
> Поспешу заметить, что статья не является руководством по использованию Java IO и Java NIO. Её цель – дать людям, начинающим изучать Java, возможность понять концептуальные отличия между двумя указанными инструментами организации ввода/вывода.
> 
> Основные отличия между Java IO и Java NIO
> 
> IO NIO
> Потокоориентированный  Буфер-ориентированный
> Блокирующий (синхронный) ввод/вывод    Неблокирующий (асинхронный) ввод/вывод
> Селекторы
> 
> Потокоориентированный и буфер-ориентированный ввод/вывод
> 
> Основное отличие между двумя подходами к организации ввода/вывода в том, что Java IO является потокоориентированным, а Java NIO – буфер-ориентированным. Разберем подробней.
> 
> Потокоориентированный ввод/вывод подразумевает чтение/запись из потока/в поток одного или нескольких байт в единицу времени поочередно. Данная информация нигде не кэшируются. Таким образом, невозможно произвольно двигаться по потоку данных вперед или назад. Если вы хотите произвести подобные манипуляции, вам придется сначала кэшировать данные в буфере.
> 
> Потокоориентированный ввод:
> 
> 
> 
> Потокоориентированный вывод:
> 
> 
> 
> Подход, на котором основан Java NIO немного отличается. Данные считываются в буфер для последующей обработки. Вы можете двигаться по буферу вперед и назад. Это дает немного больше гибкости при обработке данных. В то же время, вам необходимо проверять содержит ли буфер необходимый для корректной обработки объем данных. Также необходимо следить, чтобы при чтении данных в буфер вы не уничтожили ещё не обработанные данные, находящиеся в буфере.
> 
> Блокирующий и неблокирующий ввод/вывод
> 
> Потоки ввода/вывода (streams) в Java IO являются блокирующими. Это значит, что когда в потоке выполнения (tread) вызывается read() или write() метод любого класса из пакета java.io.*, происходит блокировка до тех пор, пока данные не будут считаны или записаны. Поток выполнения в данный момент не может делать ничего другого.
> 
> Неблокирующий режим Java NIO позволяет запрашивать считанные данные из канала (channel) и получать только то, что доступно на данный момент, или вообще ничего, если доступных данных пока нет. Вместо того, чтобы оставаться заблокированным пока данные не станут доступными для считывания, поток выполнения может заняться чем-то другим.
> 
> Каналы (channels)
> 
> 
> 
> 
> Тоже самое справедливо и для неблокирующего вывода. Поток выполнения может запросить запись в канал некоторых данных, но не дожидаться при этом пока они не будут полностью записаны.
> 
> Таким образом неблокирующий режим Java NIO позволяет использовать один поток выполнения для решения нескольких задач вместо пустого прожигания времени на ожидание в заблокированном состояний. Наиболее частой практикой является использование сэкономленного времени работы потока выполнения на обслуживание операций ввода/вывода в другом или других каналах.
> 
> Селекторы
> 
> Селекторы в Java NIO позволяют одному потоку выполнения мониторить несколько каналов ввода. Вы можете зарегистрировать несколько каналов с селектором, а потом использовать один поток выполнения для обслуживания каналов, имеющих доступные для обработки данные, или для выбора каналов, готовых для записи.
> 
> Чтобы лучше понять концепцию и выгоду от применения селекторов, давайте абстрагируемся от программирования и представим себе железнодорожный вокзал. Вариант без селектора: есть три железнодорожных пути (каналы), на каждый из них в любой момент времени может прибыть поезд (данные из буфера), на каждом пути постоянно ожидает сотрудник вокзала (поток выполнения), задача которого – обслуживание прибывшего поезда. В результате трое сотрудников постоянно находятся на вокзале даже если там вообще нет поездов. Вариант с селектором: ситуация та же, но для каждой платформы есть индикатор, сигнализирующий сотруднику вокзала (поток выполнения) о прибытии поезда. Таким образом на вокзале достаточно присутствия одного сотрудника.
> 
> Влияние Java NIO и Java IO на дизайн приложения
> 
> Выбор между Java NIO и Java IO может на следующие аспекты дизайна вашего приложения:
> 1. API обращений к классам ввода/вывода;
> 2. Обработка данных;
> 3. Количество потоков выполнения, использованных для обработки данных.
> 
> API обращений к классам ввода/вывода
> 
> Естественно, использование Java NIO серьезно отличается от использования Java IO. Так как, вместо чтения данных байт за байтом с использованием, например InputStream, данные для начала должны быть считаны в буфер и браться для обработки уже оттуда.
> 
> Обработка данных
> 
> Обработка данных при использовании Java NIO тоже отличается.
> Как уже упоминалось, при использовании Java IO вы читаете данные байт за байтом с InputStream или Reader. Представьте, что вы проводите считывание строк текстовой информации:
> 
> Name: Anna
> Age: 25
> Email: anna@mailserver.com
> Phone: 1234567890
> 
> Этот поток строк текста может обрабатываться следующим образом:
> 
> InputStream input = ... ;
> BufferedReader reader = new BufferedReader(new InputStreamReader(input));
> String nameLine   = reader.readLine();
> String ageLine    = reader.readLine();
> String emailLine  = reader.readLine();
> String phoneLine  = reader.readLine();
> 
> Обратите внимание, как состояние процесса обработки зависит от того, насколько далеко продвинулось выполнение программы. Когда первый метод readLine() возвращает результат выполнения, вы уверенны – целая строка текста была считана. Метод является блокирующим и действие блокировки продолжается до тех пор, пока вся строка не будет считана. Вы также четко понимаете, что данная строка содержит имя. Подобно этому, когда метод вызывается во второй раз, вы знаете, что в результате получите возраст.
> 
> Как вы видите, прогресс в выполнении программы достигается только тогда, когда доступны новые данные для чтения, и для каждого шага вы знаете что это за данные. Когда поток выполнения достигает прогресса в считывании определенной части данных, поток ввода (в большинстве случаев) уже не двигает данные назад. Данный принцип хорошо демонстрирует следующая схема:
> 
> 
> 
> Имплементация с использованием Java IO будет выглядеть несколько иначе:
> 
> ByteBuffer buffer = ByteBuffer.allocate(48);
> int bytesRead = inChannel.read(buffer);
> 
> Обратите внимание на вторую строчку кода, в которой происходит считывание байтов из канала в ByteBuffer. Когда возвращается результат выполнения данного метода, вы не можете быть уверенны, что все необходимые вам данные находятся внутри буфера. Все, что вам известно, так это то, что буфер содержит некоторые байты. Это немного усложняет процесс обработки.
> 
> Представьте, что после первого вызова метода read(buffer), в буфер было считано только половину строки. Например, “Name: An”. Сможете ли вы обработать такие данные? Наверное, что нет. Вам придется ждать пока, по крайней мере, одна полная строка текста не будет считана в буфер.
> 
> Так как же вам узнать, достаточно ли данных для корректной обработки содержит буфер? А никак. Единственный вариант узнать, это посмотреть на данные, содержащиеся внутри буфера. В результате вам придется по нескольку раз проверять данные в буфере, пока они не станут доступными для корректной обработки. Это неэффективно и может негативно сказаться на дизайне программы. Например:
> 
> ByteBuffer buffer = ByteBuffer.allocate(48);
>    int bytesRead = inChannel.read(buffer);
>       while(! bufferFull(bytesRead) ) {
>           bytesRead = inChannel.read(buffer);
>       }
> 
> 
> Метод bufferFull() должен следить за тем, сколько данных считано в буфер и возвращать true или false, в зависимости от того, заполнен буфер или нет. Другими словами, если буфер готов к обработке, то он считается заполненным.
> 
> Также метод bufferFull() должен оставлять буфер в неизмененном состоянии, поскольку в противном случае следующая порция считанных данных может быть записана в неправильное место.
> 
> Если буфер заполнен, данные из него могут быть обработаны. Если он не заполнен вы все же будете иметь возможность обработать уже имеющиеся в нем данные, если это имеет смысл в вашем конкретном случае. В большинстве случаев – это бессмысленно.
> 
> Следующая схема демонстрирует процесс определения готовности данных в буфере для корректной обработки:
> ```

Его sha256:

```
d4207b430474caff9010fb42eae5b7d74df06a5201dc27cc5a16e2d5255dcd15
```

Теперь передаем файл:

```
d4207b430474caff9010fb42eae5b7d74df06a5201dc27cc5a16e2d5255dcd15
```

Действительно, переда файла работает верно.

Референсы:

```
https://github.com/Daniil1380/client
https://github.com/Daniil1380/Server
https://github.com/Daniil1380/ClientNonBlock
https://github.com/Daniil1380/ServerNonBlock
```

